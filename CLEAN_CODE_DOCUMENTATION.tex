\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}

\geometry{margin=1in}

% Code listing style
\lstset{
    language=JavaScript,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numberstyle=\tiny\color{gray},
    numbers=left,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=2
}

% Header and Footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{LMS Project - Clean Code Documentation}
\fancyfoot[C]{\thepage}

% Title formatting
\titleformat{\section}
{\Large\bfseries\color{blue}}
{}{0em}
{}[\titlerule]

\titleformat{\subsection}
{\large\bfseries}
{}{0em}
{}

\title{
    \textbf{Clean Code Strategies Implementation} \\
    \large Learning Management System (LMS) Project \\
    \vspace{0.5cm}
    \normalsize Comprehensive Documentation
}

\author{Development Team}
\date{\today}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}

This document provides comprehensive documentation of clean code strategies implemented across the Learning Management System (LMS) project. The project follows industry-standard clean code principles to ensure maintainability, readability, and scalability.

\subsection{Project Overview}

The LMS is a web-based platform designed for:
\begin{itemize}
    \item Video-based training management
    \item Assessment creation and tracking
    \item User progress monitoring
    \item Role-based access control
    \item Real-time dashboard updates
\end{itemize}

\subsection{Technology Stack}

\begin{itemize}
    \item \textbf{Frontend:} React.js, Redux Toolkit, RTK Query, Tailwind CSS
    \item \textbf{Backend:} Node.js, Express.js, MongoDB
    \item \textbf{Authentication:} JWT with Redux Persist
    \item \textbf{State Management:} Redux Toolkit with RTK Query
\end{itemize}

\section{Clean Code Principles Applied}

\subsection{Code Readability}

\subsubsection{Meaningful Naming Conventions}

All variables, functions, and classes use descriptive names that clearly indicate their purpose.

\textbf{Before (Poor Naming):}
\begin{lstlisting}
const bp = "http://localhost:7000/";
const gp = () => { /* ... */ };
\end{lstlisting}

\textbf{After (Clean Code):}
\begin{lstlisting}
/**
 * API Configuration
 * Centralized base URL configuration for the application
 */
const API_CONFIG = {
    baseUrl: process.env.VITE_API_URL || "http://localhost:7000/",
};

/**
 * Retrieves authentication token from localStorage
 * 
 * @returns {string|null} - Authentication token or null if not found
 */
const getAuthToken = () => {
    try {
        return localStorage.getItem('token');
    } catch (error) {
        console.error('Failed to retrieve auth token:', error);
        return null;
    }
};
\end{lstlisting}

\subsubsection{Function Size and Single Responsibility}

Functions are kept small and focused on a single responsibility.

\textbf{Example - API Utility Functions:}
\begin{lstlisting}
/**
 * Builds authorization header if token exists
 * 
 * @param {string|null} token - Authentication token
 * @returns {Object} - Headers object with Authorization if token exists
 */
const buildAuthHeaders = (token) => {
    if (!token) return {};
    return { Authorization: `Bearer ${token}` };
};

/**
 * Merges default and custom options for fetch request
 * 
 * @param {Object} defaultOptions - Default fetch options
 * @param {Object} customOptions - Custom options to merge
 * @returns {Object} - Merged options object
 */
const mergeFetchOptions = (defaultOptions, customOptions) => {
    const mergedOptions = {
        ...defaultOptions,
        ...customOptions,
        headers: {
            ...defaultOptions.headers,
            ...customOptions.headers,
        },
    };
    
    const token = getAuthToken();
    const authHeaders = buildAuthHeaders(token);
    
    mergedOptions.headers = {
        ...mergedOptions.headers,
        ...authHeaders,
    };
    
    return mergedOptions;
};
\end{lstlisting}

\subsubsection{Consistent Formatting}

All code follows consistent formatting standards:
\begin{itemize}
    \item 2-space indentation
    \item Semicolons for statement termination
    \item Consistent brace placement
    \item Proper spacing around operators
\end{itemize}

\subsubsection{Limiting Nesting Depth}

Code uses early returns and guard clauses to reduce nesting depth.

\textbf{Example:}
\begin{lstlisting}
/**
 * Handles API response and extracts JSON data
 * 
 * @param {Response} response - Fetch response object
 * @returns {Promise<any>} - Parsed JSON data
 * @throws {Error} - If response is not ok or parsing fails
 */
const handleApiResponse = async (response) => {
    if (!response.ok) {
        const errorMessage = `HTTP error! status: ${response.status}`;
        throw new Error(errorMessage);
    }
    
    try {
        return await response.json();
    } catch (parseError) {
        throw new Error(`Failed to parse response: ${parseError.message}`);
    }
};
\end{lstlisting}

\subsection{Code Structure}

\subsubsection{Logical Project Structure}

The project follows a feature-based directory structure:

\begin{verbatim}
frontend/src/
├── api/              # API utilities and configuration
├── components/       # Reusable UI components
├── features/         # Feature-based Redux slices
│   ├── auth/         # Authentication feature
│   └── dashboard/   # Dashboard API queries
├── pages/           # Page-level components
├── store/           # Redux store configuration
└── main.jsx         # Application entry point
\end{verbatim}

\subsubsection{Single Responsibility Principle (SRP)}

Each module has a single, well-defined responsibility:

\begin{itemize}
    \item \texttt{api/api.js} - Handles all API communication
    \item \texttt{features/dashboard/dashboardApi.js} - Dashboard data queries
    \item \texttt{store/store.js} - Redux store configuration
\end{itemize}

\subsubsection{Modularization}

Large files are split into smaller, reusable modules:

\begin{lstlisting}
// api/api.js - Centralized API utilities
export const apiCall = async (endpoint, options = {}) => {
    // Implementation
};

// features/dashboard/dashboardApi.js - Feature-specific queries
export const dashboardApi = createApi({
    // RTK Query configuration
});
\end{lstlisting}

\subsubsection{DRY Principle (Don't Repeat Yourself)}

Common logic is extracted into reusable functions:

\textbf{Example - Configuration Constants:}
\begin{lstlisting}
/**
 * Cache tag types for RTK Query invalidation
 */
const CACHE_TAG_TYPES = {
    DASHBOARD_DATA: 'DashboardData',
    EMPLOYEE_COUNT: 'EmployeeCount',
    HOME_PROGRESS: 'HomeProgress',
    // ... more types
};

/**
 * RTK Query cache configuration
 * No caching enabled for real-time updates
 */
const CACHE_CONFIG = {
    keepUnusedDataFor: 0,
    refetchOnMountOrArgChange: true,
    refetchOnFocus: true,
    refetchOnReconnect: true,
};

// Used across all endpoints
getDashboardProgress: builder.query({
    // ...
    providesTags: [CACHE_TAG_TYPES.DASHBOARD_DATA],
    ...CACHE_CONFIG,
}),
\end{lstlisting}

\subsection{Error Handling \& Validation}

\subsubsection{Try-Catch Blocks}

All async operations are wrapped in try-catch blocks:

\begin{lstlisting}
/**
 * Generic API call function with error handling
 */
export const apiCall = async (endpoint, options = {}) => {
    const url = `${API_CONFIG.baseUrl}${endpoint}`;
    const finalOptions = mergeFetchOptions(DEFAULT_FETCH_OPTIONS, options);
    
    try {
        const response = await fetch(url, finalOptions);
        return await handleApiResponse(response);
    } catch (error) {
        console.error(`API call to ${endpoint} failed:`, error.message);
        
        // Try CORS proxy fallback only in development
        if (process.env.NODE_ENV === 'development') {
            try {
                return await tryCorsProxyFallback(url, finalOptions);
            } catch (corsError) {
                console.error('CORS proxy fallback failed:', corsError.message);
                throw corsError;
            }
        }
        
        throw error;
    }
};
\end{lstlisting}

\subsubsection{Meaningful Error Messages}

Error messages clearly describe what went wrong:

\textbf{Good Error Messages:}
\begin{itemize}
    \item \texttt{"HTTP error! status: 404"}
    \item \texttt{"Failed to retrieve auth token"}
    \item \texttt{"CORS proxy failed: Connection timeout"}
\end{itemize}

\textbf{Poor Error Messages (Avoided):}
\begin{itemize}
    \item \texttt{"Error occurred"}
    \item \texttt{"Something went wrong"}
    \item \texttt{"Failed"}
\end{itemize}

\subsubsection{Input Validation}

Functions validate inputs before processing:

\begin{lstlisting}
/**
 * Builds query parameters for video completion request
 * 
 * @param {Object} params - Video completion parameters
 * @returns {URLSearchParams} - Query parameters object
 */
const buildVideoCompletionParams = ({ userId, trainingId, moduleId, videoId, watchTime, totalDuration }) => {
    const params = new URLSearchParams({
        userId,
        trainingId,
        moduleId,
        videoId,
    });

    if (watchTime) {
        params.append('watchTime', watchTime.toString());
    }
    
    if (totalDuration) {
        params.append('totalDuration', totalDuration.toString());
    }

    return params;
};
\end{lstlisting}

\subsection{Comments \& Documentation}

\subsubsection{JSDoc Documentation}

All functions are documented with JSDoc comments:

\begin{lstlisting}
/**
 * Marks a video as complete for a user
 * 
 * @param {Object} params - Parameters for marking video complete
 * @param {string} params.userId - User ID
 * @param {string} params.trainingId - Training ID
 * @param {string} params.moduleId - Module ID
 * @param {string} params.videoId - Video ID
 * @param {number} [params.watchTime] - Watch time in seconds (optional)
 * @param {number} [params.totalDuration] - Total duration in seconds (optional)
 * @returns {Promise<any>} - API response data
 * @throws {Error} - If API call fails
 */
export const markVideoAsComplete = async (params) => {
    const queryParams = buildVideoCompletionParams(params);
    const endpoint = `api/user/update/trainingprocess?${queryParams.toString()}`;
    
    return await apiCall(endpoint, {
        method: HTTP_METHODS.PATCH,
    });
};
\end{lstlisting}

\subsubsection{Why Comments, Not What Comments}

Comments explain \textit{why} code exists, not \textit{what} it does:

\textbf{Good Comment:}
\begin{lstlisting}
/**
 * Dashboard API reducer - no persistence for real-time updates
 * Ensures fresh data on every mount for accurate dashboard metrics
 */
\end{lstlisting}

\textbf{Poor Comment (Avoided):}
\begin{lstlisting}
// Sets keepUnusedDataFor to 0
keepUnusedDataFor: 0,
\end{lstlisting}

\subsubsection{Updated Documentation}

All comments are kept in sync with code changes. When functions are refactored, documentation is updated accordingly.

\subsection{Testing \& Code Quality}

\subsubsection{Linting}

The project uses ESLint for automatic code quality checks:

\begin{verbatim}
# ESLint configuration
eslint.config.js
\end{verbatim}

\subsubsection{Code Reviews}

All code changes undergo peer review before merging to ensure:
\begin{itemize}
    \item Adherence to clean code principles
    \item Consistency across the codebase
    \item Proper error handling
    \item Documentation completeness
\end{itemize}

\subsection{Performance \& Optimization}

\subsubsection{Efficient Data Fetching}

RTK Query is used for efficient API calls:

\begin{lstlisting}
/**
 * RTK Query API slice for dashboard data
 * Handles all dashboard-related API calls with real-time updates
 */
export const dashboardApi = createApi({
    reducerPath: 'dashboardApi',
    baseQuery: fetchBaseQuery({ 
        baseUrl: API_CONFIG.baseUrl,
        credentials: 'include',
    }),
    tagTypes: Object.values(CACHE_TAG_TYPES),
    endpoints: (builder) => ({
        getDashboardProgress: builder.query({
            query: () => ({
                url: 'api/get/progress',
                method: 'GET',
                headers: getAuthHeaders(),
            }),
            providesTags: [CACHE_TAG_TYPES.DASHBOARD_DATA],
            ...CACHE_CONFIG,
        }),
    }),
});
\end{lstlisting}

\subsubsection{Optimization After Profiling}

Performance optimizations are made only after identifying bottlenecks. The project prioritizes:
\begin{itemize}
    \item Code readability
    \item Maintainability
    \item Then performance optimization
\end{itemize}

\subsection{Version Control \& Deployment}

\subsubsection{Clear Commit Messages}

All commits follow a clear message format:

\begin{verbatim}
feat: enable automatic data refresh with RTK Query polling
refactor: apply clean code principles to API utilities
fix: resolve authentication token retrieval error handling
\end{verbatim}

\subsubsection{Branch Management}

The project maintains:
\begin{itemize}
    \item Clean, focused branches
    \item Regular updates from main
    \item Code review before merging
\end{itemize}

\section{File-by-File Clean Code Implementation}

\subsection{Frontend Files}

\subsubsection{api/api.js}

\textbf{Clean Code Improvements:}
\begin{itemize}
    \item Replaced \texttt{baseUrl} with \texttt{API\_CONFIG} constant
    \item Extracted helper functions: \texttt{getAuthToken()}, \texttt{buildAuthHeaders()}, \texttt{mergeFetchOptions()}
    \item Added comprehensive JSDoc documentation
    \item Implemented proper error handling with meaningful messages
    \item Used constants for HTTP methods
\end{itemize}

\textbf{Key Functions:}
\begin{lstlisting}
- apiCall() - Main API call function
- getAuthToken() - Safe token retrieval
- buildAuthHeaders() - Header construction
- mergeFetchOptions() - Options merging
- handleApiResponse() - Response processing
- tryCorsProxyFallback() - Development fallback
- markVideoAsComplete() - Video completion API
- updateVideoProgress() - Progress tracking API
\end{lstlisting}

\subsubsection{features/dashboard/dashboardApi.js}

\textbf{Clean Code Improvements:}
\begin{itemize}
    \item Centralized cache tag types in \texttt{CACHE\_TAG\_TYPES} constant
    \item Extracted cache configuration to \texttt{CACHE\_CONFIG}
    \item Added helper function \texttt{getAuthToken()} for safe token access
    \item Comprehensive JSDoc documentation for all endpoints
    \item Used constants instead of magic strings
\end{itemize}

\subsubsection{store/store.js}

\textbf{Clean Code Improvements:}
\begin{itemize}
    \item Added comprehensive file-level documentation
    \item Extracted configuration constants
    \item Documented all configuration objects
    \item Clear separation of concerns
\end{itemize}

\section{SOLID Principles}

\subsection{Single Responsibility Principle (SRP)}

Each module has one reason to change:
\begin{itemize}
    \item \texttt{api/api.js} - Only handles API communication
    \item \texttt{store/store.js} - Only configures Redux store
    \item \texttt{features/dashboard/dashboardApi.js} - Only handles dashboard queries
\end{itemize}

\subsection{Open/Closed Principle}

The codebase is open for extension but closed for modification:
\begin{itemize}
    \item New API endpoints can be added without modifying existing code
    \item New features can extend the store without changing core configuration
\end{itemize}

\subsection{Liskov Substitution Principle}

Interface contracts are maintained:
\begin{itemize}
    \item All API functions return consistent response formats
    \item Error handling follows consistent patterns
\end{itemize}

\subsection{Interface Segregation Principle}

Functions are focused and do not force unnecessary dependencies:
\begin{itemize}
    \item Small, focused utility functions
    \item Functions accept only required parameters
\end{itemize}

\subsection{Dependency Inversion Principle}

High-level modules depend on abstractions:
\begin{itemize}
    \item API calls depend on configuration constants
    \item Store configuration depends on reducer interfaces
\end{itemize}

\section{KISS and YAGNI Principles}

\subsection{Keep It Simple, Stupid (KISS)}

\begin{itemize}
    \item Simple, readable code preferred over clever solutions
    \item Clear function names that describe intent
    \item Straightforward error handling
\end{itemize}

\subsection{You Aren't Gonna Need It (YAGNI)}

\begin{itemize}
    \item Features implemented only when needed
    \item No premature optimization
    \item No unused utility functions
\end{itemize}

\section{Best Practices Summary}

\subsection{Naming Conventions}

\begin{itemize}
    \item \textbf{Constants:} \texttt{UPPER\_SNAKE\_CASE} (e.g., \texttt{API\_CONFIG})
    \item \textbf{Functions:} \texttt{camelCase} with verb prefix (e.g., \texttt{getAuthToken()})
    \item \textbf{Components:} \texttt{PascalCase} (e.g., \texttt{HomeData})
    \item \textbf{Files:} \texttt{camelCase.js} or \texttt{PascalCase.jsx}
\end{itemize}

\subsection{Code Organization}

\begin{itemize}
    \item Imports at the top
    \item Constants after imports
    \item Helper functions before main exports
    \item Main exports at the bottom
\end{itemize}

\subsection{Documentation Standards}

\begin{itemize}
    \item All public functions have JSDoc comments
    \item Complex logic has inline comments explaining \textit{why}
    \item Configuration objects are documented
    \item Examples provided for complex APIs
\end{itemize}

\subsection{Error Handling Patterns}

\begin{itemize}
    \item Try-catch blocks for all async operations
    \item Meaningful error messages
    \item Proper error propagation
    \item Fallback mechanisms where appropriate
\end{itemize}

\section{Refactoring Examples}

\subsection{Before and After Comparison}

\textbf{Before - Monolithic Function:}
\begin{lstlisting}
export const apiCall = async (endpoint, options = {}) => {
  const url = `${baseUrl.baseUrl}${endpoint}`;
  const defaultOptions = { method: 'GET', headers: {'Content-Type': 'application/json'}, credentials: 'include' };
  const finalOptions = {...defaultOptions, ...options, headers: {...defaultOptions.headers, ...options.headers}};
  const token = localStorage.getItem('token');
  if (token) finalOptions.headers.Authorization = `Bearer ${token}`;
  try {
    const response = await fetch(url, finalOptions);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error);
    throw error;
  }
};
\end{lstlisting}

\textbf{After - Clean, Modular Functions:}
\begin{lstlisting}
/**
 * Generic API call function with error handling and CORS fallback
 */
export const apiCall = async (endpoint, options = {}) => {
    const url = `${API_CONFIG.baseUrl}${endpoint}`;
    const finalOptions = mergeFetchOptions(DEFAULT_FETCH_OPTIONS, options);
    
    try {
        const response = await fetch(url, finalOptions);
        return await handleApiResponse(response);
    } catch (error) {
        console.error(`API call to ${endpoint} failed:`, error.message);
        
        if (process.env.NODE_ENV === 'development') {
            try {
                return await tryCorsProxyFallback(url, finalOptions);
            } catch (corsError) {
                console.error('CORS proxy fallback failed:', corsError.message);
                throw corsError;
            }
        }
        
        throw error;
    }
};
\end{lstlisting}

\section{Conclusion}

This documentation outlines the comprehensive clean code strategies implemented throughout the LMS project. By following these principles:

\begin{itemize}
    \item \textbf{Maintainability:} Code is easy to understand and modify
    \item \textbf{Readability:} Clear naming and structure
    \item \textbf{Scalability:} Modular architecture supports growth
    \item \textbf{Reliability:} Proper error handling and validation
    \item \textbf{Collaboration:} Well-documented code aids team development
\end{itemize}

\section{References}

\begin{itemize}
    \item Clean Code by Robert C. Martin
    \item JavaScript: The Good Parts by Douglas Crockford
    \item Redux Toolkit Documentation
    \item RTK Query Best Practices
    \item ESLint Configuration Guide
\end{itemize}

\vspace{2cm}

\begin{center}
    \textbf{Document Version:} 1.0 \\
    \textbf{Last Updated:} \today \\
    \textbf{Maintained By:} Development Team
\end{center}

\end{document}

